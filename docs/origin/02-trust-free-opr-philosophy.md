이걸 왜 만들었겠어. 널 못 믿어서지. 

내가 요청한걸 바로 수행하지 말라고. 
너는 믿음이 안가 신뢰도가 없어 . 
그러니까 오더를 만들라고. 

내가 요청한걸 너가 어떻게 이해하고 어떤 동작을 할건지 검사를 받으라고 
너가 또 이상하게 수정하고 만들게 불보듯 뻔하니까.

오더를 만들고 지키라고. 
오더를 시작하면 이제 오더는 수정하지 말라고. 너가 하기로 한 초기계획을 왜 수정해. 
프로그레스를 그래서 만드는거잖아. 거기에 로그를 기록하라고
모든 작업 기록을 프로그레스에 남기라고. 
너가 한 작업을 뭐 했는지 내가 보고 수정하고. 
당연히 니가 만드는 기능들에 생기는 버그를 체크하고 수정사항을 하라고 지시를 하고 
그 모든 것들을 프로그레스 단계에서는 무한히 진행을 하는거야. 
언제까지? 내가 이제 됐다 라고 할때까지. 

오더도 내가 만들라고해. 
오더 진행라고 내가 이야기를해. 
오더 완료도 내가 말을 하는건데 
왜 너가 하냐고. 

널 못믿어서 만드는 작업인데. 
프로젝트에 박아두라고. 신뢰를 못하니까 이걸 쓰는거라고 
그러니까 시키는거 넘어서 작업을 하지 말라고. 요청한거 그대로 작업을 하라고. 

그렇게 오더를 완료를 시키면. 
다음에 신규 오더를 만들때 너가 또 이전 오더를 까먹고 작업을 하니까 
이전 오더들을 참고해서 작업을 하라고 하는거 아니야. 

근데 그냥 참고하라고 하면 오더/프로그레스/리포트를 멋대로 참조할게 불보듯 뻔하잖아? 
자꾸 없던 내용, 과거 내용들을 스펙이라고 우기니까? 

오더가 생기고 프로그레스로 진행되면 그 오더를 내가 완료시키는 시점에서 
초기 오더랑 비교해서 무슨 작업이 결과적으로 수행되었는지를 리포트로 작성하는거잖아 
그리고 리포트를 스펙 문서에 업데이트를 하고 메모리셀에도 만들어두는거고, 기존 수정이면 업데이트를 시키는거고 
프로그레스의 버그 수정과정을 버그별로 이슈별로 분리해서 
버그별 메모리셀이나 이슈별 메모리셀처럼 과정에 대해서 기술을 해서 적는거고 

그러니까 태스크는 오더-리포트 만 보면 파악이 된다고 
근데 왜 프로그레스가 있겠어? 그 오더-리포트를 하려고 하는데 버그가 일어났고 어떻게 수정했고 
어떤 이슈가 있었고 어떻게 수정했고
오더를 어떻게 수행하려고 했는데 어떻게 왜곡했고 그 기록이 담긴거잖아 

그러니까 그 하나의 태스크, 오더-프로그레스-리포트 를 히스토리에 아카이빙해서 보관을 하라고 
보관을 하면서 태스크의 내용을 분석해보면 오더와 리포트를 보면 스펙이 어떻게 변경되었는지를 알 수 있고 최종 스펙이 리포트인거고 
그러면 그 리포트의 내용을 스펙문서에 업데이트를 하고 메모리셀에도 만들어두는거고, 기존 수정이면 업데이트를 시키는거고 
프로그레스의 버그 수정과정을 버그별로 이슈별로 분리해서 
버그별 메모리셀이나 이슈별 메모리셀처럼 과정에 대해서 기술을 해서 적는거고 

이게 최초의 오더 명령어에서 파생되어 있으니까 
오더를 분석해서 기능 수정이 일어났다도 
리포트에서 결과로 보이는 스펙인거니까 
그 오더 자체도 프로그레스나 리포트로 만들어진 메모리셀과 연관이 있으니 
오더 자체도 메모리셀로 만들면 서로 연관성이 생길테고 

그렇게 하나의 태스크가 수많음 메모리 셀로 만들어지면 
다른 태스크가 완료되서 그걸 메모리셀로 업데이트 할때 
비슷한 이슈나 비슷한 버그가 있다면 
신규로 안 만들어도 비슷한 부분은 메모리가 분할하기도 하고 
때로는 합쳐지기도 하면서 업데이트가 되고 연관성이 생기는거고 

이게 스펙문서 관점에서 본다면 스펙 문서도 그렇게 수많은 메모리 셀로 바꿀수가 있는거고 


다시 오더를 새로 만들떄 오더를 분석하려고 할때 
단순히 오더만 생기는게 아니고 메모리들을 참고해서 어떤 메모리셀과 연광이 있는지 적어두면 
새로운 세션에서 이어할 수 있고 

위의 내용을 정리해서 오리진 철학 문서로 docs 스펙 문서에 하나 정리해놔. 
내가 말하는 내용을 그대로 넣어두는 docs/origin 을 따로 해놓고 
위의 내용을 스펙 문서에 녹여서 docs/specs 에 반영을 하고 
나머지도 odd-kit 내용에 따라서 턴메모리를 수행하든 뭐하든 적용시켜놓으라고 
